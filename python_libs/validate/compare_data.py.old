
from maintenance_loader import *

import os, sys, hashlib, time, shutil, re
import csv
from sys import version_info



def sortLogByPath(logpath):
	writefile = open(logpath+'.tmp', 'w')
	readfile = csv.reader(open(logpath), delimiter=",")
	filteredRows = filter(lambda x: len(x) > 3, readfile)
	for line in sorted(filteredRows, key=lambda line: line[3]):
		strng=','.join(line)
		writefile.write(strng+'\n')
	writefile.close()

	os.remove(logpath)
	os.rename(logpath+".tmp",logpath)


def getBestMaster(masterpath):
	def checkMasterName(val1,val2,masterpath):
		val1i=val1
		val2i=val2
		mastername = buildMasterName(val1i,val2i)
		mpath = masterpath+mastername
		if os.path.exists(mpath):
			return True;
		return False

	def buildMasterName(val1,val2):
		while( len(str(val1)) < 8 ):
			# adds 0's to clock time denomination as necessary
			val1="0"+str(val1)
		while( len(str(val2)) < 6 ):
			# adds 0's to clock time denomination as necessary
			val2="0"+str(val2)
		bestfit=str(val1)+'-'+str(val2)
		bestmaster = 'master-'+bestfit+'/'
		bestmaster += 'md5vali-master-'+bestfit+'.txt'
		return bestmaster

	if not os.path.exists(masterpath):
		try:
			os.makedirs(masterpath)
		except OSError as exception:
			if exception.errno != errno.EEXIST:
				raise

	highmaster = None
	try:
		masterlist = driveutils.readDir(masterpath)
	except OSError as exception:
		raise
	if len(masterlist) == 0:
		return None
	masterlist.sort()

	bestfit1=0
	bestfit2=0
	for mastern in masterlist:
		namestr = str(mastern)
#		if re.match('^md5vali-master-\d+-\d+\.txt\s*$',namestr):
#			groups = re.findall(r'^md5vali-master-(\d+-\d+)\.txt\s*$',namestr)
		if re.match('^master-\d+-\d+\s*$',namestr):
			groups = re.findall(r'^master-(\d+-\d+)\s*$',namestr)
			vals = groups[0].split('-')
			val = int(vals[0])

			if(val > bestfit1):
				if(checkMasterName(val,int(vals[1]),masterpath)==True):
					bestfit1=val
					bestfit2=int(vals[1])
			elif(val == bestfit1):
				if(bestfit2 < int(vals[1])):
					if(checkMasterName(val,int(vals[1]),masterpath)==True):
						bestfit1=val
						bestfit2=int(vals[1])

	if(bestfit1 > 0) and (bestfit2 > 0):
		bestmaster = buildMasterName(bestfit1,bestfit2)
		return bestmaster

def actOnUseOpts(stage,useopts,masterlist,logsetname,etcdata=None):
	py3 = version_info[0] > 2 #creates boolean value for test that Python major version > 2
	if etcdata is None:
		etcdata={}

	if stage == 'add':
		if 'dropold' in useopts.keys():
			if etcdata['compset']['ptype'] == "sXdXmP":
				return 'exit'
		elif 'askdropold' in useopts.keys() and 'logitem' in etcdata.keys():
			if etcdata['compset']['ptype'] == "sXdXmP":
				if '_holddata' not in useopts.keys():
					useopts['_holddata']={}
				if 'askold' not in useopts['_holddata'].keys():
					useopts['_holddata']['askold']=[]
				useopts['_holddata']['askold'].append({'line':etcdata['logitem']['line'],'set':etcdata['compset']})
				return 'exit'

	if stage == 'end':
		if 'askdropold' in useopts.keys():
			if '_holddata' in useopts.keys():
				if 'askold' in useopts['_holddata'].keys():
					print
					print
					for obj in useopts['_holddata']['askold']:
						reline = obj['line']
						reline = re.findall("^(?:[^,]+,){3}.*?\/\/(.*)$",reline)[0]
						print reline
					print
					print "These files were not found."
					print "Do you wish to remove these missing files from the master list?"
					if py3:
						conf = input()
					else:
						conf = raw_input()
					print
					if re.match("^\s*([Yy](?:[Ee][Ss])?)\s*$",conf):
						print "Removed."
					else:
						newlog=masterlist['_newmaster']
						for obj in useopts['_holddata']['askold']:
							fullpath = re.findall(r'(\/\/.*)$',obj['line'])[0]
							startline = re.findall(r'^(\w+,\s*\d+,[^,]+,\s*)\/',obj['line'])[0]
							masterline = startline+"/masterpath/"+logsetname+fullpath+"\n"

							newlog['obj'].write(masterline)
						print "Canceling removal."



##################################################

def beginCompareStage(loglist,runname,masterroute,timestamp,targetlist,datasets,useopts=None):
	def grabAMasterLog(masterpath,timestamp):
		masterlog = getBestMaster(masterpath)
		if masterlog == None:
			vals = timestamp.split('-')
			val1 = int(vals[0])
			val2 = int(vals[1])-1
			while( len(str(val2)) < 6 ):
				# adds 0's to clock time denomination as necessary
				val2="0"+str(val2)

#			masterlog = 'md5vali-master-'+str(val1)+'-'+str(val2)+'.txt'
			masterlog = 'master-'+str(val1)+'-'+str(val2)+'/'
			masterlog += 'md5vali-master-'+str(val1)+'-'+str(val2)+'.txt'
			driveutils.createNewLog(masterpath+masterlog,False)
		masterlog=masterpath+masterlog
		return masterlog

	if useopts is None:
		useopts={}

#	print '--- a ---', runname

	masterlog=grabAMasterLog(masterroute,timestamp)
#	newmasterlog=masterroute+'md5vali-master-'+timestamp+'.txt'
	newmasterlog=masterroute+'master-'+timestamp+'/'
	newmasterlog+='md5vali-master-'+timestamp+'.txt'
#	print runname,masterlog,loglist

	for logsetname,logset in loglist.iteritems():
		compareSourcesAndTargets(runname,masterlog,newmasterlog,logset,logsetname,targetlist,datasets,useopts)


	summarylog = masterroute+'md5vali-summary-'+timestamp+'.txt'
	driveutils.createNewLog(summarylog,True)

	print '----------------------------------------------'
	print
	driveutils.addToLog( "----------------------------------------------\n\n", summarylog )

	os.rename(newmasterlog+".tmp",newmasterlog)
	sortLogByPath(newmasterlog)

	print
	print '----------------------------------------------'
	print '-----------------totals-----------------------'
	driveutils.addToLog( "\n----------------------------------------------\n", summarylog )
	driveutils.addToLog( "-----------------totals-----------------------\n", summarylog )

	for runname,runset in useopts['_holddata']['totals'].iteritems():
		for logsetname,logset in useopts['_holddata']['totals'][runname].iteritems():
			for tname,nameset in useopts['_holddata']['totals'][runname][logsetname].iteritems():
				strr=""
				for tresult,val in nameset.iteritems():
					strr=strr+tresult+"="+str(val)+'  '
				print ' - totals: ',runname,'-',logsetname,'-',tname,' : '+strr.rstrip()
				driveutils.addToLog( ' - totals:  '+runname+' - '+logsetname+' - '+tname+'  :  '+strr.rstrip()+"\n", summarylog )
#			useopts['_holddata']['totals'][runname][logsetname][tname][tresult]+=1
	print '----------------------------------------------'
	print '-----------------overall-----------------------'
	driveutils.addToLog( "----------------------------------------------\n", summarylog )
	driveutils.addToLog( "-----------------overall-----------------------\n", summarylog )
	strr=""
	for tresult,val in useopts['_holddata']['overalltotals'].iteritems():
		strr=strr+tresult+': '+str(val)+',   '
	print ' - sets:   ',(strr.rstrip())[0:-1]
	strr=(strr.rstrip())[0:-1]
	driveutils.addToLog( ' - sets:    '+strr+"\n", summarylog )
#			useopts['_holddata']['overalltotals'][grouptype]=0
	useopts['_holddata']['overalltotals']={}


	if 'errset' in datasets.keys():
		print
		print '----------------------------------------------'
		for typename,typelist in datasets['errset'].iteritems():
			print '------------------',typename,'-----------------------'
			for item in typelist:
				print item
		print '----------------------------------------------'
		print

def compareSourcesAndTargets(runname,masterlog,newmasterlog,logset,logsetname,targetlist,datasets,useopts=None):
	if useopts is None:
		useopts={}

	steplist={}
#	i=0
	for logname,logpath in logset.iteritems():
		logAf = open(logpath, 'rb')
		steplist[logname]={}
		steplist[logname]['obj']=logAf
		steplist[logname]['pos']=0
		steplist[logname]['logpath']=logpath
		steplist[logname]['logname']=logname
#		i=i+1

	masterlist={}

	masterlist['_oldmaster']={}
	logBf = open(masterlog, 'rb')
	masterlist['_oldmaster']['obj']=logBf
	masterlist['_oldmaster']['logpath']=masterlog
	masterlist['_oldmaster']['pos']=0

	masterlist['_newmaster']={}
	driveutils.createNewLog(newmasterlog+'.tmp',True)
	logBf = open(newmasterlog+'.tmp', 'ab')
	masterlist['_newmaster']['obj']=logBf
	masterlist['_newmaster']['logpath']=newmasterlog

	masterlist['_newmaster']['altpath']=re.findall('^(.*)\/',newmasterlog)[0]
	masterlist['_newmaster']['alttime']=re.findall('^.*-(\d+-\d+)\/',newmasterlog)[0]


	print

	def resetLogPos(logitem):
		curpos=logitem['obj'].tell()
		if curpos != logitem['pos']:
			logitem['obj'].seek( logitem['pos'] )

	def pushMasterListToGroup(masterlist,logsetname):
		for name,item in masterlist.iteritems():
			logObj = masterlist[name]['obj']
			print 't  ',name,item

			reg = r'^[A-Za-z0-9]+, [0-9]+,'
			if 'line' in item.keys():
				print 'y  ',item['line']
				while re.search(reg,item['line']):
#				if re.search(reg,item['line']):
					l = item['line']
#					print 'XXX',name,item['line'],masterlist.keys()
					Acompare = driveutils.decomposeFileLog(item['line'],1)
					masterlist[name]['line']=l

					groups = re.findall(r'\/masterpath\/(.*?)\/\/.*$',Acompare['fullpath'])
					groupname=groups[0]

#					print groupname,l

					if groupname != logsetname:
#						print 'skip: ',groupname, logsetname, name
						incrementListed(masterlist,[name])
						loadStepList(masterlist)
						prepStepListVals(masterlist)
					else:
#						print 'up: ',groupname, logsetname, masterlist.keys()
						loadStepList(masterlist)
						prepStepListVals(masterlist)
						break

	def incrementListed(steplist,inclist):
#		print
#		print '  inclist: ',inclist
		for name in inclist:
#			print '   . ',name,steplist.keys()
			if name in steplist.keys():
#				print '   . . ',steplist[name]['pos'],steplist[name]['obj'].tell()
				steplist[name]['pos']=steplist[name]['obj'].tell()

	def loadStepList(steplist):
		for name,item in steplist.iteritems():
			logObj = steplist[name]['obj']

			if 'pos' in item.keys():
#				steplist[name]['pos']=logObj.tell()
				resetLogPos(steplist[name])
				aline=logObj.readline()
#				print '##',name,aline
#				if aline is None:
#					print "#!"
				steplist[name]['line']=aline

	def prepStepListVals(steplist):
		for name,item in steplist.iteritems():
			reg = r'^[A-Za-z0-9]+, [0-9]+,'
			regE1 = r'^\*+, [0-9]+,'
			regE2 = r'^[A-Za-z0-9]+, -1,'

			if 'loadErr' in steplist[name].keys():
				del steplist[name]['loadErr']


			if 'line' in item.keys():
				print 'x ',name,item.keys(),item['line'].rstrip()
				if re.search(reg,item['line']):
					l = item['line']
					Acompare = driveutils.decomposeFileLog(item['line'],1)
					steplist[name]['cur_sha']=Acompare['sha']

					groups = re.findall(r'\/(\/.*)$',Acompare['fullpath'])
					steplist[name]['cur_path']=groups[0]

					steplist[name]['line']=l
				elif re.search(regE1,item['line']) or re.search(regE2,item['line']):
					l = item['line']
					Acompare = driveutils.decomposeFileLog(item['line'],1)
					steplist[name]['cur_sha']=Acompare['sha']

					groups = re.findall(r'\/(\/.*)$',Acompare['fullpath'])
					steplist[name]['cur_path']=groups[0]
					steplist[name]['loadErr']=True
					steplist[name]['line']=l
				else:
	#				print "########",name,item
					steplist[name]['cur_path']=None
					steplist[name]['cur_sha']=None

	def comparePathsInLogSet(matches,filelist):
		for n,item in filelist.iteritems():
			if 'cur_path' in item.keys():
				curpath = item['cur_path']
				print '@ ',n,item['pos'],curpath,item.keys()
				if curpath is not None:
					if curpath not in matches.keys():
						matches[curpath]=[]

					matches[curpath].append(n)
		return matches

	def findLowestPath(matches):
		lowest=None
		for n,item in matches.iteritems():
#			print '==',n,item
			if lowest is None:
				lowest=n
			elif lowest>n:
				lowest=n
#		print
		print 'found: ',lowest
		return lowest

	def getSHAset(pathset,SHAset,filelist):
		for n,item in filelist.iteritems():
			if 'cur_sha' in item.keys():
				if n in pathset:
					SHAset[n]=filelist[n]
				else:
					SHAset[n]=0
		return SHAset

	def compareSHAset(shaset):
		ptype=""
		hasS=False
		for i,item in shaset.iteritems():
#			print '...', i,isinstance(shaset[i],dict),item
			if i != "_oldmaster" and i != "_newmaster":
				if not isinstance(shaset[i],dict):
					# s:P ~ d:X ~ m:??
					ptype="sPdXm"
				else:
					hasS=True
		if not ptype == "":
			if not hasS:
				ptype="sXdXm"
		if '_oldmaster' in shaset.keys() and len(shaset.keys()) == 1:
				# s:X ~ d:X ~ m:??
				ptype="sXdXm"
		if ptype == "":
			# s:P ~ d:P ~ m:??
			ptype="sPdPm"
		if '_oldmaster' in shaset.keys() and isinstance(shaset['_oldmaster'],dict):
			ptype=ptype+"P"
		else:
			ptype=ptype+"X"

		msha=""
		stype=""
		curpath=""
		if '_oldmaster' in shaset.keys() and isinstance(shaset['_oldmaster'],dict):
			if 'cur_sha' in shaset['_oldmaster'].keys():
				msha = shaset['_oldmaster']['cur_sha']
			if 'cur_path' in shaset['_oldmaster'].keys():
				curpath = shaset['_oldmaster']['cur_path']
		hasS=False
		for i,item in shaset.iteritems():
#			print '--',i,isinstance(item,dict),item
			if isinstance(item,dict) and 'cur_path' in item.keys():
				if curpath == "":
					curpath = item['cur_path']
			if isinstance(item,dict) and 'cur_sha' in item.keys():
				if 'loadErr' in item.keys():
					stype="sEdEm"
					break
				elif msha == "":
					msha = item['cur_sha']
				elif item['cur_sha'] != msha:
					stype="sSdS'm"
		if stype == "":
			stype="sSdSm"
		if '_oldmaster' in shaset.keys() and isinstance(shaset['_oldmaster'],dict):
			if 'cur_sha' in shaset['_oldmaster'].keys():
				stype=stype+"S"
			else:
				stype=stype+"X"
		else:
			stype=stype+"X"


		compset={}
		compset['sha']=msha
		compset['ptype']=ptype
		compset['stype']=stype
		compset['path']=curpath
		return compset

	def incrementPtrs(shaset,steplist):
		inclist=[]
#		print
		for i,item in shaset.iteritems():
#			print 'add: ', i,isinstance(item,dict),item
			if isinstance(item,dict):
				inclist.append(i)
		incrementListed(steplist,inclist)

	def closeUpFiles(filelist):
		for i,item in filelist.iteritems():
			if 'obj' in item.keys():
				item['obj'].close()
#				print 'closed: ',i

	def	writeOutput(compset,newlog,runname,steplist,masterlist,datasets,useopts=None):
		if useopts is None:
			useopts={}
#		print compset.keys(),newlog.keys()
#		print compset
#		print
#		print compset

		matchnames=[]
		logitem={}
		listptrs=[steplist,masterlist]
		for listp in listptrs:
			for i,item in listp.iteritems():
				if 'cur_sha' in item.keys():
					if item['cur_sha'] is not None:
						if compset['sha'] == item['cur_sha']:
							if item['line'] != "":
								logitem['cur_sha'] = item['cur_sha']
								logitem['cur_path'] = item['cur_path']
								logitem['line'] = item['line']
								matchnames.append(i)

#					print '#',i,item['cur_path'], (compset['sha'] == item['cur_sha']), item.keys()

		print ' = = = ',logitem,compset
		if re.match("^.*(?:sE|dE|mE)",compset['stype']):
			resolveViaError(compset,steplist,masterlist,newlog,logitem,matchnames,runname,logsetname,datasets,useopts)
		elif 'line' in logitem.keys() and logitem['line'] is not None:
			resolveViaLogs(compset,steplist,newlog,logitem,matchnames,runname,logsetname,datasets,useopts)


		return matchnames

	def addToTotalCount(optcount,runname,logsetname,findings):
		if 'overalltotals' not in optcount.keys():
			optcount['overalltotals']={}

		if 'totals' not in optcount.keys():
			optcount['totals']={}
		if runname not in optcount['totals'].keys():
			optcount['totals'][runname]={}
		if logsetname not in optcount['totals'][runname].keys():
			optcount['totals'][runname][logsetname]={}
		for tname,tresult in findings.iteritems():
			if tname not in optcount['totals'][runname][logsetname].keys():
				optcount['totals'][runname][logsetname][tname]={}
			if tresult not in optcount['totals'][runname][logsetname][tname].keys():
				optcount['totals'][runname][logsetname][tname][tresult]=0

			optcount['totals'][runname][logsetname][tname][tresult]+=1

		stuff=findings.values()
		grouptype = 'present'
		if 'error' in stuff:
			grouptype = 'error'
		elif 'conflict' in stuff:
			grouptype = 'conflict'
		elif 'missing' in stuff:
			grouptype = 'missing'
		elif 'new' in stuff:
			grouptype = 'new'

		if grouptype not in optcount['overalltotals'].keys():
			optcount['overalltotals'][grouptype]=0
		optcount['overalltotals'][grouptype]+=1
		return grouptype
#			if tresult == 'new':
#			if tresult == 'present':
#			if tresult == 'conflict':
#			if tresult == 'missing':

	def	resolveViaLogs(compset,steplist,newlog,logitem,matchnames,runname,logsetname,datasets,useopts=None):
		if useopts is None:
			useopts={}

		fullpath = re.findall(r'(\/\/.*)$',logitem['line'])[0]
		startline = re.findall(r'^(\w+,\s*\d+,[^,]+,\s*)\/',logitem['line'])[0]
		masterline = startline+"/masterpath/"+logsetname+fullpath+"\n"

		# ADD TO MISSING LOG
		if compset['ptype'] == "sXdXmP":
			if '_holddata' not in useopts.keys():
				useopts['_holddata']={}

			print
			logpath=masterlist['_newmaster']['altpath']+'/md5vali-missing-'+masterlist['_newmaster']['alttime']+'.txt'
			driveutils.createNewLog(logpath,True)
			driveutils.addToLog( masterline, logpath )

			obj={}
			for lname in datasets['logset'][runname][logsetname].keys():
				obj[lname]='missing'
			addToTotalCount(useopts['_holddata'],runname,logsetname,obj)

		val = actOnUseOpts('add',useopts,masterlist,logsetname,{'logitem':logitem,'compset':compset})
		print "#1 ",val,logitem,compset
		if val == 'exit':
			return

		action=''

		if compset['ptype'] == "sPdPmP":
			if compset['stype'] == "sSdS'mS" or compset['stype'] == "sS'dSmS":
				action="conflict"
			if compset['stype'] == "sSdS'mS'" or compset['stype'] == "sS'dSmS'":
				action="conflict"
		elif compset['ptype'] == "sPdPmX":
			if re.match("^sSdS",compset['stype']):
				action="new"
			if re.match("^sS'dS",compset['stype']) or re.match("^sSdS'",compset['stype']):
				action="new conflict"
		elif compset['ptype'] == "sPdXmP" or compset['ptype'] == "sXdPmP":
			if re.match(".*[ds]S'.*",compset['stype']):
				action="conflict one missing"
			else:
				action="one missing"
		elif compset['ptype'] == "sPdXmX" or compset['ptype'] == "sXdPmX":
			action="new one missing"

#		print masterlist['_newmaster'].keys()		#['logpath', 'altpath', 'obj', 'alttime']
#		print matchnames,compset,logitem,steplist.keys()
#		for i,item in steplist.iteritems():
#			print i,'-',item
#		print action
		#[0, 'old']
		#{'sha': '7de9352b38a384006c90532f0660719394b2cc1e3893bca0762eb13a0cbc3286', 'ptype': 'sPdPmP', 'stype': 'sSdSmS'}
		#{'cur_path': '/the-legend-of-koizumi-7618513.jpg', 'cur_sha': '7de9352b38a384006c90532f0660719394b2cc1e3893bca0762eb13a0cbc3286', 'line': '7de9352b38a384006c90532f0660719394b2cc1e3893bca0762eb13a0cbc3286, 254503, Sat May 28 18:55:31 2016, /masterpath//the-legend-of-koizumi-7618513.jpg\n'}
		#[0] ['obj', 'cur_path', 'logpath', 'pos', 'line', 'cur_sha']
		overall = None
		if action=="":
			if '_holddata' not in useopts.keys():
				useopts['_holddata']={}

			obj={}
			for lname in datasets['logset'][runname][logsetname].keys():
				obj[lname]='present'
			addToTotalCount(useopts['_holddata'],runname,logsetname,obj)
		else:
			obj={}
			for logn in steplist.keys():
				print 'b  ',compset['ptype'], logn, matchnames, compset['path'], steplist[logn]['cur_path']
				if compset['path'] == steplist[logn]['cur_path']:
					if logn in matchnames:
						if re.match("^sEdEm",compset['stype']):
							obj[logn]='error'
						elif re.match(".*mX.*",compset['ptype']):
							obj[logn]='new'
						else:
							obj[logn]='present'
					elif re.match("^sEdEm",compset['stype']):
						obj[logn]='error'
					else:
						obj[logn]='conflict'
				elif re.match("^sEdEm",compset['stype']):
					obj[logn]='error'
				else:
					obj[logn]='missing'
#				print '    ..',logn,obj[logn]

			if '_holddata' not in useopts.keys():
				useopts['_holddata']={}
			overall=addToTotalCount(useopts['_holddata'],runname,logsetname,obj)

			logpath=masterlist['_newmaster']['altpath']+'/md5vali-'+overall+'-'+masterlist['_newmaster']['alttime']+'.txt'
			driveutils.createNewLog(logpath,True)

			driveutils.addToLog( "\n-------- md5 "+overall+" --------\n", logpath )
			print
			print "-------- md5 "+overall+" --------"
			if re.match(".*mX.*",compset['ptype']):
				print "master - missing, "+"/masterpath/"+logsetname+fullpath
#				driveutils.addToLog( "master - missing, "+masterline, logpath )
				driveutils.addToLog( "master - missing, "+"/masterpath/"+logsetname+fullpath+"\n", logpath )
			else:
				print "master - "+masterline.rstrip()
				driveutils.addToLog( "master - "+masterline, logpath )
			for logn in steplist.keys():
				if compset['path'] == steplist[logn]['cur_path']:
					if logn in matchnames:
						print logn,"- match, "+steplist[logn]['line'].rstrip()
						driveutils.addToLog( logn+"- match, "+steplist[logn]['line'], logpath )
					else:
						print logn,"- conflict, "+steplist[logn]['line'].rstrip()
						driveutils.addToLog( logn+"- conflict, "+steplist[logn]['line'], logpath )
				else:
#					print '**',runname,logsetname,logn,datasets['found'].keys(),datasets['targets'].keys()
					pathA = datasets['found'][logn]
					pathB = datasets['targets'][logsetname][logn]
					print logn,"- missing, "+pathA+pathB+'/'+compset['path']
					driveutils.addToLog( logn+"- missing, "+pathA+pathB+'/'+compset['path']+'\n', logpath )
			print "------------------------------"
			driveutils.addToLog( "------------------------------\n", logpath )
		print

		## ADD TO MASTER PATH
		if overall != "conflict" and overall != "error":
			print "==== ",masterline
			newlog['obj'].write(masterline)

	def	resolveViaError(compset,steplist,masterlist,newlog,logitem,matchnames,runname,logsetname,datasets,useopts=None):
		if '_holddata' not in useopts.keys():
			useopts['_holddata']={}

#		print compset,steplist.keys(),masterlist['_oldmaster'].keys(),steplist,'  @@@@  ',newlog,'  @@@@  ',logitem,matchnames,runname
		if(masterlist['_oldmaster']['line'] == ''):
			fullpath = '/'+compset['path']
			startline = "**********, **********, **********, "
		elif not re.match(".*mX.*",compset['ptype']):
			fullpath = re.findall(r'(\/\/.*)$',masterlist['_oldmaster']['line'])[0]
			startline = re.findall(r'^(\w+,\s*\d+,[^,]+,\s*)\/',masterlist['_oldmaster']['line'])[0]
		else:
			fullpath = '/'+compset['path']
			startline = "**********, **********, **********, "

		masterline = startline+"/masterpath/"+logsetname+fullpath+"\n"

		obj={}
		for logn in steplist.keys():
#			print 'E   ',compset['ptype'], logn, matchnames, compset['path'], steplist[logn]
			if 'loadErr' in steplist[logn].keys() and steplist[logn]['loadErr']:
				obj[logn]='error'
			elif compset['path'] == steplist[logn]['cur_path']:
				if logn in matchnames:
					if re.match(".*mX.*",compset['ptype']):
						obj[logn]='new'
					else:
						obj[logn]='present'
				else:
					obj[logn]='conflict'
			else:
				obj[logn]='missing'

		overall=addToTotalCount(useopts['_holddata'],runname,logsetname,obj)

		logpath=masterlist['_newmaster']['altpath']+'/md5vali-'+overall+'-'+masterlist['_newmaster']['alttime']+'.txt'
		driveutils.createNewLog(logpath,True)

		driveutils.addToLog( "\n-------- md5 "+overall+" --------\n", logpath )
		print
		print "-------- md5 "+overall+" --------"
		if re.match(".*mX.*",compset['ptype']):
			print "master - missing, "+"/masterpath/"+logsetname+fullpath
#			driveutils.addToLog( "master - missing, "+masterline, logpath )
			driveutils.addToLog( "master - missing, "+"/masterpath/"+logsetname+fullpath+"\n", logpath )
		else:
			print "master - "+masterline.rstrip()
			driveutils.addToLog( "master - "+masterline, logpath )
		for logn in steplist.keys():
			if compset['path'] == steplist[logn]['cur_path']:
				if 'loadErr' in steplist[logn].keys() and steplist[logn]['loadErr']:
					print logn,"- error, "+steplist[logn]['line'].rstrip()
					driveutils.addToLog( logn+"- error, "+steplist[logn]['line'], logpath )
				elif logn in matchnames:
					print logn,"- match, "+steplist[logn]['line'].rstrip()
					driveutils.addToLog( logn+"- match, "+steplist[logn]['line'], logpath )
				else:
					print logn,"- conflict, "+steplist[logn]['line'].rstrip()
					driveutils.addToLog( logn+"- conflict, "+steplist[logn]['line'], logpath )
			else:
#					print '**',runname,logsetname,logn,datasets['found'].keys(),datasets['targets'].keys()
				pathA = datasets['found'][logn]
				pathB = datasets['targets'][logsetname][logn]
				print logn,"- missing, "+pathA+pathB+'/'+compset['path']
				driveutils.addToLog( logn+"- missing, "+pathA+pathB+'/'+compset['path']+'\n', logpath )
		print "------------------------------"
		driveutils.addToLog( "------------------------------\n", logpath )
		print

		## ADD TO MASTER PATH
		if re.match(r'^(\w+,\s*\d+,[^,]+,\s*)',masterline):
			print "==== ",masterline
			newlog['obj'].write(masterline)

	def stepCompareLogs(c,steplist,masterlist,runname,logsetname,datasets,useopts=None):
		if useopts is None:
			useopts={}

		loadStepList(steplist)
		prepStepListVals(steplist)

		loadStepList(masterlist)
		prepStepListVals(masterlist)
		pushMasterListToGroup(masterlist,logsetname)
#		print

		matches = {}
		comparePathsInLogSet(matches,steplist)
		comparePathsInLogSet(matches,masterlist)

#		print
		for i,item in matches.iteritems():
			print ':',i,item

		lowest = findLowestPath(matches)
		if lowest is None:
			print '----------------------------------------------'
			return {'count':None,'lowest':None}

		SHAset = {}
		getSHAset(matches[lowest],SHAset,steplist)
		getSHAset(matches[lowest],SHAset,masterlist)
#		print

		for i,item in SHAset.iteritems():
			print '%',i,item
#		print

		compset = compareSHAset(SHAset)
		for i,item in compset.iteritems():
			print '>',i,item
#		print
#		print

		matchnames = writeOutput(compset,masterlist['_newmaster'],runname,steplist,masterlist,datasets,useopts)
		print '#',c,'!',lowest,'!', compset['ptype'],compset['stype'],matchnames

		incrementPtrs(SHAset,steplist)
		incrementPtrs(SHAset,masterlist)

		print '----------------------------------------------'
		return {'count':c+1,'lowest':lowest}

	c=0
	opath=''
#	print masterlist['_oldmaster']
	while True:
		col=stepCompareLogs(c,steplist,masterlist,runname,logsetname,datasets,useopts)
#		print '| check: ',c,opath,col['lowest']
#		print '----------------------------------------------'
		if(opath == col['lowest'] and c>0):
			break
		if(col['lowest'] is None and col['count'] is None):
			break
		c=col['count']
		opath=col['lowest']

	actOnUseOpts('end',useopts,masterlist,logsetname)

	closeUpFiles(steplist)
	closeUpFiles(masterlist)
#	return
#	os.rename(newmasterlog+".tmp",newmasterlog)
	sortLogByPath(newmasterlog+".tmp")
